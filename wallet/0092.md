# BRC-92: Unified, Standardized, Vendor-Neutral, Unchanging, and Open BSV Blockchain Standard Wallet-to-Application Interface

Ty Everett (ty@projectbabbage.com)

## Abstract

We define the BSV Blockchain's standard wallet-to-application interface. This interface defines a robust and secure communication protocol between BSV wallets and applications. This protocol, built on the Babbage architectural principles, aims to standardize the interaction between wallets and decentralized applications in the BSV ecosystem. The interface is designed to be vendor-neutral, supporting a wide range of implementations, ensuring interoperability, and promoting openness across different wallet and app vendors.

## Primary Objectives

1.  **Standardization**: The interface provides a consistent and standardized API that ensures that any application can integrate with any compliant wallet without needing custom adaptations.

2.  **Vendor-Neutrality**: The interface abstracts the underlying wallet implementation, allowing applications to work seamlessly with wallets from different vendors.

3.  **Open Specification**: The interface is openly documented, encouraging community adoption, and providing a bedrock foundation atop which anyone can build with confidence, knowing the interface will remain constant.

4.  **Security and Privacy**: Emphasizing secure handling of keys, transactions, and data through the use of secure cryptographic protocols and minimal exposure of sensitive information.

5.  **Comprehensive Functionality**: The interface covers a broad range of functionalities, from transaction creation, signing, and broadcasting, to identity management, encryption, and digital signatures.

## Interface Structure

The interface comprises numerous methods that cater to different functional areas related to wallet operations and application needs. The methods are grouped for easier understanding:

### Transaction Operations:
-   **Creation**: `createAction` allows for constructing complex Bitcoin transactions with multiple inputs, outputs, and options that customize how the transaction behaves, such as whether it should be broadcast or only partially built.
-   **Signing**: `signAction` allows for signing previously created transactions from the `createAction` method.
-   **Aborting**: `abortAction` facilitates the cancellation of transactions that have not yet been completed.
-   **Internalization**: `internalizeAction` enables wallets to accept and manage incoming transactions by parsing, tagging, and organizing outputs.
-   **Listing**: `listActions` and `listOutputs` allow querying transactions and outputs based on specific criteria like labels, baskets, and tags.

### Public Key Management:
-   **Key Retrieval**: `getPublicKey` facilitates the retrieval of public keys, be they derived keys based on protocols or the user's main identity keys.
-   **Key Linkage**: Methods `revealCounterpartyKeyLinkage` and `revealSpecificKeyLinkage` disclose key relationships, essential for identity verification and the auditing of interactions between parties.

### Cryptography Operations:
-   **Encryption/Decryption**: `encrypt` and `decrypt` methods implement secure encryption and decryption of data using derived keys and consistent protocol definitions, enabling private exchanges of information between counterparties.
-   **HMAC Operations**: `createHmac` and veri`fyHmac allow for the creation and verification of Hash-based Message Authentication Codes (HMAC) to ensure data integrity.
-   **Signatures**: `createSignature` and `verifySignature` enable the creation and verification of digital signatures, both public and private, essential for validating the authenticity of transactions, documents, and data.

### Identity and Certificate Management:
-   **Certificate Acquisition**: `acquireCertificate` allows the wallet to obtain identity certificates, either by directly saving them or through a standardized issuance protocol.
-   **Certificate Listing and Discovery**: `listCertificates`, `discoverByIdentityKey`, and `discoverByAttributes` enable querying of identity certificates owned by the user or others based on identity keys or specific attributes.
-   **Proving Identity Certificates**: `proveCertificate` is utilized in situations where a user's identity or certified attributes need to be proven to a third party.

### Blockchain and Network Data:
-   **Blockchain Height**: `getHeight` retrieves the current height of the blockchain.
-   **Merkle Root Retrieval**: `getMerkleRootForHeight` retrieves the Merkle root at a specific block height.
-   **Network and Version Information**: `getNetwork` and `getVersion` retrieve information about the network (mainnet or testnet) and the wallet's version.

### Authentication:
-   **User Authentication**: `isAuthenticated` checks the user's authentication status, ensuring they've set up their wallet before operations are attempted.
-   **Authentication Wait**: `waitForAuthentication` waits for the user to complete authentication and returns once the wallet has been fully set up.

## Data Types and Constraints

To ensure consistency and prevent errors, the interface defines various data types and associated constraints. A few key examples include:

### Boolean Types:
-   `BooleanDefaultFalse`: Defaults to false if not provided.
-   `BooleanDefaultTrue`: Defaults to true if not provided.

### Integer Types:
-   `Byte`: An integer between 0 and 255.
-   `PositiveIntegerOrZero`: A non-negative integer with an upper bound of 2^32 - 1.
-   `PositiveIntegerMax10`: A positive integer between 1 and 10.
-   `SatoshiValue`: Represents a value in Satoshis, ranging between 1 and 2.1 * 10^15.

### String Types:
-   `ISOTimestampString`: Represents an ISO 8601 format timestamp.
-   `HexString`: A string containing hexadecimal characters.
-   `Base64String`: A string in standard base64 encoded format.
-   **Specialized Strings**: Defined for specific fields, including descriptions, version strings, certificate field names, etc.

## Error Handling and Validation

Errors are returned using a uniform structure containing:
-   `status`: Denotes the presence of a failure (always "error").
-   `code`: A short machine-readable string representing the specific error or fault.
-   `description`: A human-readable explanation of the error.
-   `context`: (Optional) Additional contextual data relevant to the error---often binary or debug information.

## Usage and Best Practices

-   **Interoperability**: Since the interface is vendor-neutral, developers should ensure they comply fully with the defined types, constraints, and method contracts, allowing their wallets and applications to interface smoothly with others.

-   **Use of Privileged Mode**: Methods related to the use of keys include options that allow an alternative "privileged access" mode to be used. When implemented, a secondary and more secure set of keys is used instead of the primary ones. This should only be invoked when necessary, and requires proper justification to be provided.

-   **Request Originators and Permissions**: The interface ensures that operations like key derivation, signing, encryption, certificate field revelation, and transaction creation are conducted with proper authorization by incorporating the request's originator. The wallet can then authenticate the originator and seek user permission if necessary.

## Implementation

This interface is specified in TypeScript as follows:

```typescript
/**
 * @typedef {boolean} BooleanDefaultFalse
 * Represents an optional boolean parameter, which defaults to `false` if not provided.
 */
type BooleanDefaultFalse = boolean

/**
 * @typedef {boolean} BooleanDefaultTrue
 * Represents an optional boolean parameter, which defaults to `true` if not provided.
 */
type BooleanDefaultTrue = boolean

/**
 * @typedef {number} Byte
 * Represents an integer from 0 to 255 (inclusive).
 * @minimum 0
 * @maximum 255
 */
type Byte = number & { __type__: 'Byte', min: 0, max: 255 }

/**
 * @typedef {number} PositiveIntegerOrZero
 * A positive integer, includes zero and has an upper bound of `2^32 - 1`.
 * @minimum 0
 * @maximum 4294967295
 */
type PositiveIntegerOrZero = number & { __type__: 'PositiveIntegerOrZero', min: 0, max: 0xffffffff }

/**
 * @typedef {number} PositiveInteger
 * A positive integer that excludes zero, and has an upper bound of `2^32 - 1`.
 * @minimum 1
 * @maximum 4294967295
 */
type PositiveInteger = number & { __type__: 'PositiveInteger', min: 1, max: 0xffffffff }

/**
 * @typedef {number} PositiveIntegerMax10
 * A positive integer that excludes zero, and has an upper bound of 10.
 * @minimum 1
 * @maximum 10
 */
type PositiveIntegerMax10 = number & { __type__: 'PositiveIntegerMax10', min: 1, max: 10 }

/**
 * @typedef {number} PositiveIntegerDefault10Max10000
 * A positive integer that defaults to 10, and has an upper bound of 10000.
 * @minimum 1
 * @default 10
 * @maximum 10000
 */
type PositiveIntegerDefault10Max10000 = number & { __type__: 'PositiveIntegerDefault10Max10000', min: 0, default: 10, max: 10000 }

/**
 * @typedef {number} SatoshiValue
 * Represents a value in Satoshis, constrained by the max supply of Bitcoin (2.1 * 10^15 Satoshis).
 * @minimum 1
 * @maximum 2100000000000000
 */
type SatoshiValue = number & { __type__: 'SatoshiValue', min: 1, max: 2100000000000000 }

/**
 * @typedef {string} ISOTimestampString
 * Represents an ISO timestamp string.
 */
type ISOTimestampString = string & { __type__: 'ISOTimestampString' }

/**
 * @typedef {string} HexString
 * A string containing only hexadecimal characters (0-9, a-f).
 */
type HexString = string & { __type__: 'HexString' }

/**
 * @typedef {HexString} TXIDHexString
 * Represents a transaction ID, enforced to be exactly 64 characters in length and in hexadecimal format.
 * @length 64
 */
type TXIDHexString = HexString & { length: 64, __type__: 'TXIDHexString' }

/**
 * @typedef {string} OutpointString
 * Represents a transaction ID and output index pair. The TXID is given as a hex string followed by a period "." and then the output index is given as a decimal integer.
 */
type OutpointString = string & { __type__: 'OutpointString' }

/**
 * @typedef {HexString} PubKeyHex
 * Represents a compressed DER secp256k1 public key, exactly 66 hex characters (33 bytes) in length.
 * @length 66
 */
type PubKeyHex = HexString & { length: 66, __type__: 'PubKeyHex' }

/**
 * @typedef {string} Base64String
 * A standard base64 encoded string.
 */
type Base64String = string & { __type__: 'Base64String' }

/**
 * @typedef {string} OriginatorDomainNameString
 * Represents the fully qualified domain name (FQDN) of the application that originates the request.
 */
type OriginatorDomainNameString = string & { __type__: 'OriginatorDomainNameString' }

/**
 * @typedef {string & { minLength: 5, maxLength: 50 }} DescriptionString5to50Characters
 * A string used for descriptions, with a length between 5 and 50 characters.
 */
type DescriptionString5to50Characters = string & { __type__: 'DescriptionString5to50Characters', minLength: 5, maxLength: 50 }

/**
 * @typedef {string & { maxLength: 300 }} BasketStringUnder300Characters
 * A string for naming baskets, with a maximum length of 300 characters.
 */
type BasketStringUnder300Characters = string & { __type__: 'BasketStringUnder300Characters', maxLength: 300 }

/**
 * @typedef {string & { maxLength: 300 }} OutputTagStringUnder300Characters
 * A string for tagging outputs, with a maximum length of 300 characters.
 */
type OutputTagStringUnder300Characters = string & { __type__: 'OutputTagStringUnder300Characters', maxLength: 300 }

/**
 * @typedef {string & { maxLength: 300 }} LabelStringUnder300Characters
 * A string for labeling transactions, with a maximum length of 300 characters.
 */
type LabelStringUnder300Characters = string & { __type__: 'LabelStringUnder300Characters', maxLength: 300 }

/**
 * @typedef {Byte[]} BEEF
 * An array of integers, each ranging from 0 to 255, indicating transaction data in BEEF format.
 */
type BEEF = Byte[]

/**
 * @typedef {string & { minLength: 5, maxLength: 400 }} ProtocolString5To400Characters
 * A protocol identifier with a length between 5 and 400 characters.
 */
type ProtocolString5To400Characters = string & { __type__: 'ProtocolString5To400Characters', minLength: 5, maxLength: 400 }

/**
 * @typedef {string & { maxLength: 800 }} KeyIDStringUnder800Characters
 * Represents a key identifier string, with a maximum length of 800 characters.
 */
type KeyIDStringUnder800Characters = string & { __type__: 'KeyIDStringUnder800Characters', maxLength: 800 }

/**
 * @typedef {string & { maxLength: 50 }} CertificateFieldNameUnder50Characters
 * Represents a certificate field name with a maximum length of 50 characters.
 */
type CertificateFieldNameUnder50Characters = string & { __type__: 'CertificateFieldNameUnder50Characters', maxLength: 50 }

/**
 * @typedef {string & { maxLength: 100 }} EntityNameStringMax100Characters
 * Represents a trusted entity name with a maximum length of 100 characters.
 */
type EntityNameStringMax100Characters = string & { __type__: 'EntityNameStringMax100Characters', maxLength: 100 }

/**
 * @typedef {string & { maxLength: 500 }} EntityIconURLStringMax500Characters
 * Represents a trusted entity icon URL with a maximum length of 500 characters.
 */
type EntityIconURLStringMax500Characters = string & { __type__: 'EntityIconURLStringMax500Characters', maxLength: 500 }

/**
 * @typedef {string & { minLength: 7, maxLength: 30 }} VersionString7To30Characters
 * Represents a version string, with a length between 7 and 30 characters.
 * 
 * The format is [vendor]-[major].[minor].[patch]
 */
type VersionString7To30Characters = string & { __type__: 'VersionString7To30Characters', minLength: 7, maxLength: 30 }

/**
 * @typedef {string & { minLength: 10, maxLength: 40 }} ErrorCodeString10To40Characters
 * Represents a machine-readable error code string, with a length between 10 and 40 characters.
 */
type ErrorCodeString10To40Characters = string & { __type__: 'ErrorCodeString10To40Characters', minLength: 10, maxLength: 40 }

/**
 * @typedef {string & { minLength: 20, maxLength: 200 }} ErrorDescriptionString20To200Characters
 * Represents a human-readable error description string, with a length between 20 and 200 characters.
 */
type ErrorDescriptionString20To200Characters = string & { __type__: 'ErrorDescriptionString20To200Characters', minLength: 20, maxLength: 200 }

/**
 * The Wallet interface defines a wallet capable of various tasks including transaction creation and signing,
 * encryption, decryption, identity certificate management, identity verification, and communication 
 * with applications as per the BRC standards. This interface allows applications to interact with
 * the wallet for a range of functionalities aligned with the Babbage architectural principles.
 */
export default interface Wallet {

   /**
    * Creates a new Bitcoin transaction based on the provided inputs, outputs, labels, locks, and other options.
    *
    * @param {Object} args - The arguments required to create the transaction.
    * @param {DescriptionString5to50Characters} args.description - A human-readable description of the action represented by this transaction.
    * @param {Array<Object>} [args.inputs] - An optional array of input objects used in the transaction. 
    * @param {BEEF} [args.inputs[].beef] - BEEF format required on the first input consuming from the associated transaction.
    * @param {TXIDHexString} args.inputs[].txid - The transaction ID of the transaction containing the output being spent.
    * @param {PositiveIntegerOrZero} args.inputs[].outputIndex - The output index of the specific output to consume.
    * @param {HexString} args.inputs[].unlockingScript - The unlocking script needed to release the specified UTXO.
    * @param {DescriptionString5to50Characters} args.inputs[].inputDescription - A description of this input for contextual understanding of what it consumes.
    * @param {PositiveIntegerOrZero} [args.inputs[].sequenceNumber] - An optional sequence number applied to the input.
    * @param {PositiveInteger} [args.inputs[].unlockingScriptLength] - Length of the unlocking script, in case it will be provided later using `signAction`.
    * @param {Array<Object>} [args.outputs] - An optional array of output objects for the transaction.
    * @param {HexString} args.outputs[].lockingScript - The locking script that dictates how the output can later be spent.
    * @param {SatoshiValue} args.outputs[].satoshis - Number of Satoshis that constitute this output.
    * @param {DescriptionString5to50Characters} args.outputs[].outputDescription - Description of what this output represents.
    * @param {BasketStringUnder300Characters} [args.outputs[].basket] - Name of the basket where this UTXO will be held, if tracking is desired.
    * @param {string} [args.outputs[].customInstructions] - Custom instructions attached onto this UTXO, often utilized within application logic to provide necessary unlocking context or track token histories.
    * @param {OutputTagStringUnder300Characters[]} [args.outputs[].tags] - Tags assigned to the output for sorting or filtering.
    * @param {PositiveIntegerOrZero} [args.lockTime] - Optional lock time for the transaction.
    * @param {PositiveInteger} [args.version] - Optional transaction version specifier.
    * @param {LabelStringUnder300Characters[]} [args.labels] - Optional labels providing additional categorization for the transaction.
    * @param {Object} [args.options] - Optional settings modifying transaction processing behavior.
    * @param {BooleanDefaultTrue} [args.options.acceptDelayedBroadcast] - TONE PLZ DOCUMENT.
    * @param {'known'} [args.options.trustSelf] - TONE PLZ DOCUMENT.
    * @param {TXIDHexString[]} [args.options.knownTxids] - TONE PLZ DOCUMENT.
    * @param {BooleanDefaultFalse} [args.options.returnTXIDOnly] - Whether to return only the TXID of the transaction instead of BEEF.
    * @param {BooleanDefaultFalse} [args.options.noSend] - If true, the transaction will be constructed but not sent to the network.
    * @param {Array<Object>} [args.options.noSendChange] - TONE PLZ DOCUMENT.
    * @param {TXIDHexString} args.options.noSendChange[].txid - The transaction ID of the change output.
    * @param {PositiveIntegerOrZero} args.options.noSendChange[].outputIndex - The index in outputs of the change output.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} The promise returns different structures based on the outcome: error response, response with TXID, response with BEEF, or info about signable transaction.
    */
   createAction(args: {
      description: DescriptionString5to50Characters;
      inputs?: Array<
         | {
            beef?: BEEF;
            outpoint: OutpointString;
            unlockingScript: HexString;
            inputDescription: DescriptionString5to50Characters;
            sequenceNumber?: PositiveIntegerOrZero;
         }
         | {
            beef?: BEEF;
            outpoint: OutpointString;
            unlockingScriptLength: PositiveInteger;
            inputDescription: DescriptionString5to50Characters;
         }
      >;
      outputs?: {
         lockingScript: HexString;
         satoshis: SatoshiValue;
         outputDescription: DescriptionString5to50Characters;
         basket?: BasketStringUnder300Characters;
         customInstructions?: string;
         tags?: OutputTagStringUnder300Characters[];
      }[];
      lockTime?: PositiveIntegerOrZero;
      version?: PositiveIntegerOrZero;
      labels?: LabelStringUnder300Characters[];
      options?: {
         acceptDelayedBroadcast?: BooleanDefaultTrue;
         trustSelf?: 'known';
         knownTxids?: TXIDHexString[];
         returnTXIDOnly?: BooleanDefaultFalse;
         noSend?: BooleanDefaultFalse;
         noSendChange?: OutpointString[];
      };
   }, originator?: OriginatorDomainNameString): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | {
         txid: TXIDHexString;
      }
      | {
         txid: TXIDHexString;
         noSendChange: OutpointString[];
      }
      | {
         beef: BEEF;
      }
      | {
         beef: BEEF;
         noSendChange: OutpointString[];
      }
      | {
         signableTransaction: {
            beef: BEEF;
            reference: Base64String;
         };
      }
      | {
         signableTransaction: {
            beef: BEEF;
            reference: Base64String;
         };
         noSendChange: OutpointString[];
      }
   >;

   /**
    * Signs a transaction previously created using `createAction`.
    *
    * @param {Object} args - Arguments to sign the transaction.
    * @param {Record<PositiveIntegerOrZero, Object>} args.spends - Map of input indexes to the corresponding unlocking script and optional sequence number.
    * @param {HexString} args.spends[].unlockingScript - The unlocking script for the corresponding input.
    * @param {PositiveIntegerOrZero} [args.spends[].sequenceNumber] - The sequence number of the input.
    * @param {Base64String} args.reference - Reference number returned from the call to `createAction`.
    * @param {Object} [args.options] - Optional settings modifying transaction processing behavior.
    * @param {BooleanDefaultTrue} [args.options.acceptDelayedBroadcast] - TONE PLZ DOCUMENT.
    * @param {BooleanDefaultFalse} [args.options.returnTXIDOnly] - Whether only the TXID of the transaction should be returned.
    * @param {BooleanDefaultFalse} [args.options.noSend] - If true, the transaction will be signed but not broadcast.
    * @param {Array<Object>} [args.options.noSendChange] - TONE PLZ DOCUMENT.
    * @param {TXIDHexString} args.options.noSendChange[].txid - TONE PLZ DOCUMENT.
    * @param {PositiveIntegerOrZero} args.options.noSendChange[].outputIndex - TONE PLZ DOCUMENT.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} The promise returns an error response or a response with either the completed BEEF or transaction TXID.
    */
   signAction(args: {
      spends: Record<
         PositiveIntegerOrZero,
         {
            unlockingScript: HexString;
            sequenceNumber?: PositiveIntegerOrZero;
         }
      >;
      reference: Base64String;
      options?: {
         acceptDelayedBroadcast?: BooleanDefaultTrue;
         returnTXIDOnly?: BooleanDefaultFalse;
         noSend?: BooleanDefaultFalse;
         noSendChange?: OutpointString[];
      };
   }, originator?: OriginatorDomainNameString): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | {
         beef: BEEF;
      }
      | {
         txid: TXIDHexString;
      }
      | {
         txid: TXIDHexString;
         noSendChange: OutpointString[];
      }
      | {
         beef: BEEF;
         noSendChange: OutpointString[];
      }
   >;

   /**
    * Aborts a transaction that is in progress and has not yet been finalized or sent to the network.
    *
    * @param {Object} args - Arguments to identify the transaction that needs to be aborted.
    * @param {Base64String} args.reference - Reference number for the transaction to abort.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} The promise resolves to an object indicating the abortion result (either success or error).
    */
   abortAction(
      args: {
         reference: Base64String;
      },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | { aborted: true }
   >;

   /**
    * Lists all transactions matching the specified labels.
    *
    * @param {Object} args - Arguments to specify how to filter or retrieve transactions.
    * @param {LabelStringUnder300Characters[]} args.labels - An array of labels used to filter actions.
    * @param {'any' | 'all'} [args.labelQueryMode] - Specifies how to match labels (default is any which matches any of the labels).
    * @param {BooleanDefaultFalse} [args.includeLabels] - Whether to include transaction labels in the result set.
    * @param {boolean} [args.includeInputs] - Whether to include input details in the result set.
    * @param {boolean} [args.includeInputSourceLockingScripts] - Whether to include input source locking scripts in the result set.
    * @param {boolean} [args.includeInputUnlockingScripts] - Whether to include input unlocking scripts in the result set.
    * @param {boolean} [args.includeOutputs] - Whether to include output details in the result set.
    * @param {boolean} [args.includeOutputLockingScripts] - Whether to include output locking scripts in the result set.
    * @param {PositiveIntegerDefault10Max10000} [args.limit] - The maximum number of transactions to retrieve.
    * @param {PositiveIntegerOrZero} [args.offset] - Number of transactions to skip before starting to return the results.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} The promise resolves to an object containing actions, their metadata, inputs, and outputs if applicable, or an error object.
    */
   listActions(
      args: {
         labels: LabelStringUnder300Characters[];
         labelQueryMode?: 'any' | 'all';
         includeLabels?: BooleanDefaultFalse;
         includeInputs?: BooleanDefaultFalse;
         includeInputSourceLockingScripts?: BooleanDefaultFalse;
         includeInputUnlockingScripts?: BooleanDefaultFalse;
         includeOutputs?: BooleanDefaultFalse;
         includeOutputLockingScripts?: BooleanDefaultFalse;
         limit?: PositiveIntegerDefault10Max10000;
         offset?: PositiveIntegerOrZero;
      },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | {
         totalActions: PositiveIntegerOrZero;
         actions: {
            txid: TXIDHexString;
            satoshis: SatoshiValue;
            status:
            | 'completed'
            | 'unprocessed'
            | 'sending'
            | 'unproven'
            | 'unsigned'
            | 'nosend'
            | 'nonfinal';
            isOutgoing: boolean;
            description: DescriptionString5to50Characters;
            labels?: LabelStringUnder300Characters[];
            version: PositiveIntegerOrZero;
            lockTime: PositiveIntegerOrZero;
            inputs?: {
               sourceOutpoint: OutpointString;
               sourceSatoshis: SatoshiValue;
               sourceLockingScript?: HexString;
               unlockingScript?: HexString;
               inputDescription: DescriptionString5to50Characters;
               sequenceNumber: PositiveIntegerOrZero;
            }[];
            outputs?: {
               outputIndex: PositiveIntegerOrZero;
               satoshis: SatoshiValue;
               lockingScript?: HexString;
               spendable: boolean;
               outputDescription: DescriptionString5to50Characters;
               basket: BasketStringUnder300Characters;
               tags: OutputTagStringUnder300Characters[];
               customInstructions?: string;
            }[];
         }[];
      }
   >;

   /**
    * Submits a transaction to be internalized and optionally labeled, outputs paid to the wallet balance, inserted into baskets, and/or tagged.
    *
    * @param {Object} args - Arguments required to internalize the transaction.
    * @param {BEEF} args.beef - BEEF-formatted transaction to internalize.
    * @param {Array<Object>} args.outputs - Metadata about outputs, processed differently based on payment or insertion types.
    * @param {PositiveIntegerOrZero} args.outputs[].outputIndex - Index of the output within the transaction.
    * @param {'payment' | 'insert'} args.outputs[].protocol - Specifies whether the output is a payment (to be received into the wallet balance) or an insert operation (into a particular basket).
    * @param {Object} args.outputs[].remittance - Remittance data, structured accordingly for the payment or insertion operation.
    * @param {Base64String} args.outputs[].remittance.derivationPrefix - Payment-level derivation prefix used by the sender for key derivation (for payments).
    * @param {Base64String} args.outputs[].remittance.derivationSuffix - Specific output-level derivation suffix used by the sender for key derivation (for payments).
    * @param {PubKeyHex} args.outputs[].remittance.senderIdentityKey - Public identity key of the sender (for payments).
    * @param {BasketStringUnder300Characters} args.outputs[].remittance.basket - Basket in which to place the output (for insertions).
    * @param {string} [args.outputs[].remittance.customInstructions] - Optionally provided custom instructions attached to the output (for insertions).
    * @param {OutputTagStringUnder300Characters[]} [args.outputs[].remittance.tags] - Tags attached to the output (for insertions).
    * @param {DescriptionString5to50Characters} args.description - Human-readable description of the transaction being internalized.
    * @param {LabelStringUnder300Characters[]} [args.labels] - Optional labels associated with this transaction.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} The promise resolves to an object indicating the success of the operation or an error object.
    */
   internalizeAction(
      args: {
         beef: BEEF;
         outputs: {
            outputIndex: PositiveIntegerOrZero;
            protocol: 'wallet payment' | 'basket insertion';
            remittance:
            | {
               derivationPrefix: Base64String;
               derivationSuffix: Base64String;
               senderIdentityKey: PubKeyHex;
            }
            | {
               basket: BasketStringUnder300Characters;
               customInstructions?: string;
               tags?: OutputTagStringUnder300Characters[];
            };
         }[];
         description: DescriptionString5to50Characters;
         labels?: LabelStringUnder300Characters[];
      },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | { accepted: true }
   >;

   /**
    * Lists the spendable outputs kept within a specific basket, optionally tagged with specific labels.
    *
    * @param {Object} args - Arguments detailing the query for listing spendable outputs.
    * @param {BasketStringUnder300Characters} args.basket - The associated basket name whose outputs should be listed.
    * @param {OutputTagStringUnder300Characters[]} [args.tags] - Filter outputs based on these tags.
    * @param {'all' | 'any'} [args.tagQueryMode] - Filter mode, defining whether all or any of the tags must match. By default, any tag can match.
   * @param {BooleanDefaultFalse} [args.includeLockingScripts] - Whether to include locking scripts with each output in the result.
   * @param {BooleanDefaultFalse} [args.includeEntireTransactions] - Whether to include the entire transaction(s) in the result.
    * @param {BooleanDefaultFalse} [args.includeCustomInstructions] - Whether custom instructions should be returned in the result.
    * @param {BooleanDefaultFalse} [args.includeTags] - Whether the tags associated with the output should be returned.
    * @param {BooleanDefaultFalse} [args.includeLabels] - Whether the labels associated with the transaction containing the output should be returned.
    * @param {PositiveIntegerDefault10Max10000} [args.limit] - Optional limit on the number of outputs to return.
    * @param {PositiveIntegerOrZero} [args.offset] - Number of outputs to skip before starting to return results.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} The promise returns an output listing or an error object.
    */
   listOutputs(
      args:
         | {
            basket: BasketStringUnder300Characters;
            tags?: OutputTagStringUnder300Characters[];
            tagQueryMode?: 'all' | 'any';
            includeLockingScripts?: BooleanDefaultFalse;
            includeCustomInstructions?: BooleanDefaultFalse;
            includeTags?: BooleanDefaultFalse;
            includeLabels?: BooleanDefaultFalse;
            limit?: PositiveIntegerDefault10Max10000;
            offset?: PositiveIntegerOrZero;
         }
         | {
            basket: BasketStringUnder300Characters;
            tags?: OutputTagStringUnder300Characters[];
            tagQueryMode?: 'all' | 'any';
            includeEntireTransactions?: BooleanDefaultFalse;
            includeCustomInstructions?: BooleanDefaultFalse;
            includeTags?: BooleanDefaultFalse;
            includeLabels?: BooleanDefaultFalse;
            limit?: PositiveIntegerDefault10Max10000;
            offset?: PositiveIntegerOrZero;
         },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | {
         totalOutputs: PositiveIntegerOrZero;
         outputs:
         | {
            outpoint: OutpointString;
            satoshis: SatoshiValue;
            lockingScript?: HexString;
            spendable: true;
            customInstructions?: string;
            tags?: OutputTagStringUnder300Characters[];
            labels?: LabelStringUnder300Characters[];
         }[]
         | {
            outpoint: OutpointString;
            satoshis: SatoshiValue;
            beef: BEEF;
            spendable: true;
            customInstructions?: string;
            tags?: OutputTagStringUnder300Characters[];
            labels?: LabelStringUnder300Characters[];
         }[];
      }
   >;

   /**
    * Retrieves a derived or identity public key based on the requested protocol, key ID, counterparty, and other factors. 
    *
    * @param {Object} args - Arguments to specify which public key to retrieve.
    * @param {[0 | 1 | 2, ProtocolString5To400Characters]} args.protocolID - The security level and protocol string used for key derivation.
    * @param {KeyIDStringUnder800Characters} args.keyID - The key ID used for key derivation.
    * @param {BooleanDefaultFalse} [args.privileged] - Whether this is a privileged request.
    * @param {DescriptionString5to50Characters} [args.privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.
    * @param {PubKeyHex | 'self' | 'anyone'} [args.counterparty] - The public key of the counterparty involved in the key derivation process.
    * @param {BooleanDefaultFalse} [args.forSelf] - Whether to return the public key derived from the current user's own identity (as opposed to the counterparty's identity).
    * @param {BooleanDefaultFalse|true} [args.identityKey] - Use true to retrieve the current user's own identity key.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} Resolves to an object containing the public key, or an error response.
    */
   getPublicKey(
      args:
         | {
            protocolID: [0 | 1 | 2, ProtocolString5To400Characters];
            keyID: KeyIDStringUnder800Characters;
            privileged?: BooleanDefaultFalse;
            privilegedReason?: DescriptionString5to50Characters;
            counterparty?: PubKeyHex | 'self' | 'anyone';
            forSelf?: BooleanDefaultFalse;
         }
         | {
            identityKey: true;
            privileged?: BooleanDefaultFalse;
            privilegedReason?: DescriptionString5to50Characters;
         },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | { publicKey: PubKeyHex }
   >;

   /**
    * Reveals the key linkage between ourselves and a counterparty, to a particular verifier, across all interactions with the counterparty.
    *
    * @param {Object} args - Contains information about counterparty, verifier, and whether the operation is privileged.
    * @param {PubKeyHex} args.counterparty - The public key of the counterparty involved in the linkage.
    * @param {PubKeyHex} args.verifier - The public key of the verifier requesting the linkage information.
    * @param {DescriptionString5to50Characters} [args.privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.
    * @param {BooleanDefaultFalse} [args.privileged] - Whether this is a privileged request.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} Resolves to the key linkage, or an error response.
    */
   revealCounterpartyKeyLinkage(
      args: {
         counterparty: PubKeyHex;
         verifier: PubKeyHex;
         privilegedReason?: DescriptionString5to50Characters;
         privileged?: BooleanDefaultFalse;
      },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | {
         prover: PubKeyHex;
         verifier: PubKeyHex;
         counterparty: PubKeyHex;
         revelationTime: ISOTimestampString;
         encryptedLinkage: Byte[];
      }
   >;

   /**
    * Reveals the key linkage between ourselves and a counterparty, to a particular verifier, with respect to a specific interaction.
    *
    * @param {Object} args - The object defining the counterparty, verifier, protocol, and keyID for which linkage should be revealed.
    * @param {PubKeyHex} args.counterparty - The public key of the counterparty involved in the linkage.
    * @param {PubKeyHex} args.verifier - The public key of the verifier requesting the linkage information.
    * @param {[0 | 1 | 2, ProtocolString5To400Characters]} args.protocolID - The security level and protocol string associated with the linkage information to reveal.
    * @param {KeyIDStringUnder800Characters} args.keyID - The key ID associated with the linkage information to reveal.
    * @param {DescriptionString5to50Characters} [args.privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.
    * @param {BooleanDefaultFalse} [args.privileged] - Whether this is a privileged request.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} The promise returns the requested linkage information, or an error object.
    */
   revealSpecificKeyLinkage(
      args: {
         counterparty: PubKeyHex;
         verifier: PubKeyHex;
         protocolID: [0 | 1 | 2, ProtocolString5To400Characters];
         keyID: KeyIDStringUnder800Characters;
         privilegedReason?: DescriptionString5to50Characters;
         privileged?: BooleanDefaultFalse;
      },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | {
         prover: PubKeyHex;
         verifier: PubKeyHex;
         counterparty: PubKeyHex;
         protocolID: [0 | 1 | 2, ProtocolString5To400Characters];
         keyID: KeyIDStringUnder800Characters;
         encryptedLinkage: Byte[];
      }
   >;

   /**
    * Encrypts the provided plaintext data using derived keys, based on the protocol ID, key ID, counterparty, and other factors.
    *
    * @param {Object} args - Information needed for encryption, including the plaintext, protocol ID, and key ID.
    * @param {Byte[]} args.plaintext - Array of bytes constituting the plaintext data to be encrypted.
    * @param {[0 | 1 | 2, ProtocolString5To400Characters]} args.protocolID - The security level and protocol string under which the data should be encrypted.
    * @param {KeyIDStringUnder800Characters} args.keyID - Key ID under which the encryption will be performed.
    * @param {DescriptionString5to50Characters} [args.privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.
    * @param {PubKeyHex | 'self' | 'anyone'} [args.counterparty] - Public key of the counterparty (if two-party encryption is desired).
    * @param {BooleanDefaultFalse} [args.privileged] - Whether this is a privileged request.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} Resolves to the encrypted ciphertext bytes or an error if encryption fails.
    */
   encrypt(
      args: {
         plaintext: Byte[];
         protocolID: [0 | 1 | 2, ProtocolString5To400Characters];
         keyID: KeyIDStringUnder800Characters;
         privilegedReason?: DescriptionString5to50Characters;
         counterparty?: PubKeyHex | 'self' | 'anyone';
         privileged?: BooleanDefaultFalse;
      },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | { ciphertext: Byte[] }
   >;

   /**
    * Decrypts the provided ciphertext using derived keys, based on the protocol ID, key ID, counterparty, and other factors.
    *
    * @param {Object} args - Contains the ciphertext, protocol ID, and key ID required to decrypt the data.
    * @param {Byte[]} args.ciphertext - Encrypted bytes, including the initialization vector, for decryption.
    * @param {[0 | 1 | 2, ProtocolString5To400Characters]} args.protocolID - Security level and protocol string that were used during the encryption of the ciphertext.
    * @param {KeyIDStringUnder800Characters} args.keyID - Key ID used during the encryption of the ciphertext.
    * @param {DescriptionString5to50Characters} [args.privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.
    * @param {PubKeyHex | 'self' | 'anyone'} [args.counterparty] - Public identity key of the counterparty for the encryption operation.
    * @param {BooleanDefaultFalse} [args.privileged] - Whether this is a privileged request.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} Resolves to the decryption result, containing the plaintext data or an error.
    */
   decrypt(
      args: {
         ciphertext: Byte[];
         protocolID: [0 | 1 | 2, ProtocolString5To400Characters];
         keyID: KeyIDStringUnder800Characters;
         privilegedReason?: DescriptionString5to50Characters;
         counterparty?: PubKeyHex | 'self' | 'anyone';
         privileged?: BooleanDefaultFalse;
      },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | { plaintext: Byte[] }
   >;

   /**
    * Creates an HMAC (Hash-based Message Authentication Code) based on the provided data, protocol, key ID, counterparty, and other factors.
    *
    * @param {Object} args - Arguments containing the data, protocol ID, and key ID to generate the HMAC from.
    * @param {Byte[]} args.data - Input data (in bytes) for which the HMAC needs to be created.
    * @param {[0 | 1 | 2, ProtocolString5To400Characters]} args.protocolID - Security level and protocol string to be used during the HMAC operation.
    * @param {KeyIDStringUnder800Characters} args.keyID - Key ID to be used in the HMAC operation.
    * @param {DescriptionString5to50Characters} [args.privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.
    * @param {PubKeyHex | 'self' | 'anyone'} [args.counterparty] - Public identity key of the counterparty if the operation encompasses a two-party interaction.
    * @param {BooleanDefaultFalse} [args.privileged] - Whether this is a privileged request.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} Resolves to an object containing the generated HMAC bytes, or an error if the creation fails.
    */
   createHmac(
      args: {
         data: Byte[];
         protocolID: [0 | 1 | 2, ProtocolString5To400Characters];
         keyID: KeyIDStringUnder800Characters;
         privilegedReason?: DescriptionString5to50Characters;
         counterparty?: PubKeyHex | 'self' | 'anyone';
         privileged?: BooleanDefaultFalse;
      },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | { hmac: Byte[] }
   >;

   /**
    * Verifies an HMAC (Hash-based Message Authentication Code) based on the provided data, protocol, key ID, counterparty, and other factors.
    *
    * @param {Object} args - Arguments containing the HMAC data, protocol ID, and key ID needed for verification.
    * @param {Byte[]} args.data - The input data whose HMAC is to be verified.
    * @param {Byte[]} args.hmac - Byte array representing the HMAC value to be verified.
    * @param {[0 | 1 | 2, ProtocolString5To400Characters]} args.protocolID - Security level and protocol string to be used during the HMAC operation.
    * @param {KeyIDStringUnder800Characters} args.keyID - Key ID to be used during the HMAC operation.
    * @param {DescriptionString5to50Characters} [args.privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.
    * @param {PubKeyHex | 'self' | 'anyone'} [args.counterparty] - Public identity key of the counterparty if the operation encompasses a two-party interaction.
    * @param {BooleanDefaultFalse} [args.privileged] - Whether this is a privileged request.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} Resolves to an object confirming whether the HMAC was valid or an error.
    */
   verifyHmac(
      args: {
         data: Byte[];
         hmac: Byte[];
         protocolID: [0 | 1 | 2, ProtocolString5To400Characters];
         keyID: KeyIDStringUnder800Characters;
         privilegedReason?: DescriptionString5to50Characters;
         counterparty?: PubKeyHex | 'self' | 'anyone';
         privileged?: BooleanDefaultFalse;
      },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | { valid: true }
   >;

   /**
    * Creates a digital signature for the provided data or hash using a specific protocol, key, and optionally considering privilege and counterparty.
    *
    * @param {Object} args - Arguments to specify data, protocol, key ID, and privilege for creating the signature.
    * @param {Byte[]} args.data - Data to be signed using the derived private key with ECDSA.
    * @param {[0 | 1 | 2, ProtocolString5To400Characters]} args.protocolID - Security level and protocol string to be used during the signing operation.
    * @param {KeyIDStringUnder800Characters} args.keyID - Key ID to be used during the signing operation.
    * @param {DescriptionString5to50Characters} [args.privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.
    * @param {PubKeyHex | 'self' | 'anyone'} [args.counterparty] - Public identity key of the counterparty if the operation encompasses a two-party interaction.
    * @param {BooleanDefaultFalse} [args.privileged] - Whether this is a privileged request.
    * @param {Byte[]} [args.hashToDirectlySign] - Sign a pre-hashed value in situations where data can't or shouldn't be revealed, whether due to its size or for privacy.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} The promise will resolve to an object containing the DER-encoded ECDSA signature, or an error on failure.
    */
   createSignature(
      args:
         | {
            data: Byte[];
            protocolID: [0 | 1 | 2, ProtocolString5To400Characters];
            keyID: KeyIDStringUnder800Characters;
            privilegedReason?: DescriptionString5to50Characters;
            counterparty?: PubKeyHex | 'self' | 'anyone';
            privileged?: BooleanDefaultFalse;
         }
         | {
            hashToDirectlySign: Byte[];
            protocolID: [0 | 1 | 2, ProtocolString5To400Characters];
            keyID: KeyIDStringUnder800Characters;
            privilegedReason?: DescriptionString5to50Characters;
            counterparty?: PubKeyHex | 'self' | 'anyone';
            privileged?: BooleanDefaultFalse;
         },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | { signature: Byte[] }
   >;

   /**
    * Verifies a digital signature for the provided data or hash using a specific protocol, key, and optionally considering privilege and counterparty.
    *
    * @param {Object} args - Arguments specifying the data, signature, protocol, and key ID.
    * @param {Byte[]} args.data - The data originally signed, which is required for verification.
    * @param {Byte[]} args.signature - The DER-encoded ECDSA signature to validate.
    * @param {[0 | 1 | 2, ProtocolString5To400Characters]} args.protocolID - Security level and protocol string to be used during signature verification.
    * @param {KeyIDStringUnder800Characters} args.keyID - Key ID to be used during signature verification.
    * @param {DescriptionString5to50Characters} [args.privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.
    * @param {PubKeyHex | 'self' | 'anyone'} [args.counterparty] - Public identity key of the counterparty if the operation encompasses a two-party interaction.
    * @param {BooleanDefaultFalse} [args.privileged] - Whether this is a privileged request.
    * @param {Byte[]} [args.hashToDirectlyVerify] - Optional field to verify the signature against a precomputed hash instead of data.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} The promise resolves to a boolean object indicating whether the signature was valid or an error message.
    */
   verifySignature(
      args:
         | {
            data: Byte[];
            signature: Byte[];
            protocolID: [0 | 1 | 2, ProtocolString5To400Characters];
            keyID: KeyIDStringUnder800Characters;
            privilegedReason?: DescriptionString5to50Characters;
            counterparty?: PubKeyHex | 'self' | 'anyone';
            privileged?: BooleanDefaultFalse;
         }
         | {
            hashToDirectlyVerify: Byte[];
            signature: Byte[];
            protocolID: [0 | 1 | 2, ProtocolString5To400Characters];
            keyID: KeyIDStringUnder800Characters;
            privilegedReason?: DescriptionString5to50Characters;
            counterparty?: PubKeyHex | 'self' | 'anyone';
            privileged?: BooleanDefaultFalse;
         },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | { valid: true }
   >;

   /**
    * Acquires an identity certificate, whether by acquiring one from the certifier or by directly receiving it.
    *
    * @param {Object} args - Contains the type of certificate, certifier information, and fields of the certificate to be provided, among other details.
    * @param {Base64String} args.type - Type identifier for the certificate.
    * @param {Record<CertificateFieldNameUnder50Characters, string>} args.fields - The fields included within the certificate.
    * @param {PubKeyHex} args.certifier - The public identity key of the certifier.
    * @param {'issuance' | 'direct'} args.acquisitionProtocol - Specifies the acquisition process, set to either 'issuance' or 'direct'.
    * @param {string} [args.certifierUrl] - URL of the certifier where certificate acquisition requests will be sent (required when the acquisition protocol is issuance).
    * @param {PubKeyHex} [args.subject] - The public identity key of the current user, the user who is acquiring this certificate (required when the acquisition protocol is direct).
    * @param {Base64String} [args.validationKey] - Validation key of the certificate to acquire (required when the acquisition protocol is direct).
    * @param {Base64String} [args.serialNumber] - Serial number of the certificate to acquire (required when the acquisition protocol is direct).
    * @param {string} [args.revocationOutpoint] - Reference for an outpoint comprising a Bitcoin token that, if ever spent, marks the certificate as invalid (required when the acquisition protocol is direct).
    * @param {HexString} [args.signature] - Signature over the certificate (required when the acquisition protocol is direct).
    * @param {PubKeyHex | 'certifier'} [args.keyringRevealer] - The public identity key of the entity revealing the keyring to the user, if different from the certifier (required when the acquisition protocol is direct).
    * @param {Record<CertificateFieldNameUnder50Characters, Base64String>} [args.keyringForSubject] - Keyring revealing all certificate fields to the subject (required when the acquisition protocol is direct).
    * @param {BooleanDefaultFalse} [args.privileged] - Whether this is a privileged request.
    * @param {DescriptionString5to50Characters} [args.privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} The promise resolves to an object containing the acquired certificate, or an error object.
    */
   acquireCertificate(
      args:
         | {
            type: Base64String;
            fields: Record<CertificateFieldNameUnder50Characters, string>;
            certifier: PubKeyHex;
            acquisitionProtocol: 'issuance';
            certifierUrl: string;
         }
         | {
            type: Base64String;
            subject: PubKeyHex;
            validationKey: Base64String;
            serialNumber: Base64String;
            revocationOutpoint: OutpointString;
            signature: HexString;
            fields: Record<CertificateFieldNameUnder50Characters, string>;
            certifier: PubKeyHex;
            keyringRevealer: PubKeyHex | 'certifier';
            keyringForSubject: Record<CertificateFieldNameUnder50Characters, Base64String>
            acquisitionProtocol: 'direct';
         },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | {
         type: Base64String;
         subject: PubKeyHex;
         validationKey: Base64String;
         serialNumber: Base64String;
         certifier: PubKeyHex;
         revocationOutpoint: OutpointString;
         signature: HexString;
         fields: Record<CertificateFieldNameUnder50Characters, string>;
      }
   >;

   /**
    * Lists identity certificates belonging to the user, filtered by certifier(s) and type(s).
    *
    * @param {Object} args - Arguments used to filter or limit the list of certificates returned by the request.
    * @param {PubKeyHex[]} args.certifiers - An array of public keys for specific certifiers (filters by these certifiers).
    * @param {Base64String[]} args.types - An array of certificate types issued by any of the specified certifiers, which should be returned.
    * @param {PositiveIntegerDefault10Max10000} [args.limit] - Maximum number of certificates to return.
    * @param {PositiveIntegerOrZero} [args.offset] - Number of records to skip before starting to return results.
    * @param {BooleanDefaultFalse} [args.privileged] - Whether this is a privileged request.
    * @param {DescriptionString5to50Characters} [args.privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} The promise resolves to an object containing certificates or an error response.
    */
   listCertificates(
      args: {
         certifiers: PubKeyHex[];
         types: Base64String[];
         limit?: PositiveIntegerDefault10Max10000;
         offset?: PositiveIntegerOrZero;
         privileged?: BooleanDefaultFalse;
         privilegedReason?: DescriptionString5to50Characters;
      },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | {
         totalCertificates: PositiveIntegerOrZero;
         certificates: {
            type: Base64String;
            subject: PubKeyHex;
            validationKey: Base64String;
            serialNumber: Base64String;
            certifier: PubKeyHex;
            revocationOutpoint: OutpointString;
            signature: HexString;
            fields: Record<CertificateFieldNameUnder50Characters, string>;
         }[];
      }
   >;

   /**
    * Proves select fields of an identity certificate, as specified, when requested by a verifier.
    *
    * @param {Object} args - Arguments including the certificate, fields to reveal, and verifier's public key.
    * @param {Object} args.certificate - The specific identity certificate being proven.
    * @param {Base64String} args.certificate.type - The type of the certificate to be proven.
    * @param {PubKeyHex} args.certificate.subject - Public key belonging to the certificate's subject.
    * @param {Base64String} args.certificate.validationKey - Validation key associated with the certificate.
    * @param {Base64String} args.certificate.serialNumber - Unique serial number of the certificate.
    * @param {PubKeyHex} args.certificate.certifier - Public key of the certifier who issued the certificate.
    * @param {OutpointString} args.certificate.revocationOutpoint - The outpoint used to confirm that the certificate has not been revoked.
    * @param {HexString} args.certificate.signature - Certificate signature by the certifier's private key.
    * @param {Record<CertificateFieldNameUnder50Characters, string>} args.certificate.fields - All the encrypted fields present in the certificate.
    * @param {CertificateFieldNameUnder50Characters[]} args.fieldsToReveal - Array of field names that need to be revealed to the verifier.
    * @param {PubKeyHex} args.verifier - Public key of the verifier, to whom the key revelations will be made.
    * @param {BooleanDefaultFalse} [args.privileged] - Whether this is a privileged request.
    * @param {DescriptionString5to50Characters} [args.privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} Resolves to a keyring for the verifier or an error object.
    */
   proveCertificate(
      args: {
         certificate: {
            type: Base64String;
            subject: PubKeyHex;
            validationKey: Base64String;
            serialNumber: Base64String;
            certifier: PubKeyHex;
            revocationOutpoint: OutpointString;
            signature: HexString;
            fields: Record<CertificateFieldNameUnder50Characters, string>;
         };
         fieldsToReveal: CertificateFieldNameUnder50Characters[];
         verifier: PubKeyHex;
         privileged?: BooleanDefaultFalse;
         privilegedReason?: DescriptionString5to50Characters;
      },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | { keyringForVerifier: Record<CertificateFieldNameUnder50Characters, Base64String> }
   >;

   /**
    * Discovers identity certificates, issued to a given identity key by a trusted entity.
    *
    * @param {Object} args - Arguments for requesting the discovery based on the identity key.
    * @param {PubKeyHex} args.identityKey - Identity key used to filter and discover certificates.
    * @param {PositiveIntegerDefault10Max10000} [args.limit] - Maximum number of certificates to return in the response.
    * @param {PositiveIntegerOrZero} [args.offset] - Skip this number of records before starting to provide results.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} The promise resolves to the list of certificates discovered or an error object.
    */
   discoverByIdentityKey(
      args: {
         identityKey: PubKeyHex;
         limit?: PositiveIntegerDefault10Max10000;
         offset?: PositiveIntegerOrZero;
      },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | {
         totalCertificates: PositiveIntegerOrZero;
         certificates: {
            type: Base64String;
            subject: PubKeyHex;
            validationKey: Base64String;
            serialNumber: Base64String;
            certifier: PubKeyHex;
            revocationOutpoint: OutpointString;
            signature: HexString;
            fields: Record<CertificateFieldNameUnder50Characters, Base64String>;
            certifierInfo: {
               name: EntityNameStringMax100Characters;
               iconUrl: EntityIconURLStringMax500Characters;
               description: DescriptionString5to50Characters;
               trust: PositiveIntegerMax10;
            };
            publiclyRevealedKeyring: Record<CertificateFieldNameUnder50Characters, Base64String>;
            decryptedFields: Record<CertificateFieldNameUnder50Characters, string>;
         }[];
      }
   >;

   /**
    * Discovers identity certificates belonging to other users, where the documents contain specific attributes, issued by a trusted entity.
    *
    * @param {Object} args - Attributes and optional parameters used to discover certificates.
    * @param {Record<CertificateFieldNameUnder50Characters, string>} args.attributes - The attributes used to discover the certificates.
    * @param {PositiveIntegerDefault10Max10000} [args.limit] - Optional limit on the number of results returned.
    * @param {PositiveIntegerOrZero} [args.offset] - Starts retrieval of results after the specified number of records.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} The promise resolves to a list of matching certificates or an error object.
    */
   discoverByAttributes(
      args: {
         attributes: Record<CertificateFieldNameUnder50Characters, string>;
         limit?: PositiveIntegerDefault10Max10000;
         offset?: PositiveIntegerOrZero;
      },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | {
         totalCertificates: PositiveIntegerOrZero;
         certificates: {
            type: Base64String;
            subject: PubKeyHex;
            validationKey: Base64String;
            serialNumber: Base64String;
            certifier: PubKeyHex;
            revocationOutpoint: OutpointString;
            signature: HexString;
            fields: Record<CertificateFieldNameUnder50Characters, Base64String>;
            certifierInfo: {
               name: EntityNameStringMax100Characters;
               iconUrl: EntityIconURLStringMax500Characters;
               description: DescriptionString5to50Characters;
               trust: PositiveIntegerMax10;
            };
            publiclyRevealedKeyring: Record<CertificateFieldNameUnder50Characters, Base64String>;
            decryptedFields: Record<CertificateFieldNameUnder50Characters, string>;
         }[];
      }
   >;

   /**
    * Checks the authentication status of the user.
    *
    * @param {Object} args - Empty object, as no parameters are needed.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} The promise resolves to an object indicating whether the user is authenticated or an error response.
    */
   isAuthenticated(
      args: {},
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | { authenticated: boolean }
   >;

   /**
    * Continuously waits until the user is authenticated, returning the result once confirmed.
    *
    * @param {Object} args - Not used, pass an empty object.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} The final result indicating that the user is authenticated or an error object.
    */
   waitForAuthentication(
      args: {},
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | { authenticated: true }
   >;

   /**
    * Retrieves the current height of the blockchain.
    *
    * @param {Object} args - Empty object as no other parameters are necessary.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} Resolves to an object indicating the current height or an error on failure.
    */
   getHeight(
      args: {},
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | { height: PositiveInteger }
   >;

   /**
    * Retrieves the Merkle Root of a block at a specified height.
    *
    * @param {Object} args - Contains the height parameter needed to retrieve the Merkle root.
    * @param {PositiveInteger} args.height - Specifies the height at which the Merkle root needs to be retrieved.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} The promise resolves to a Merkle root hash or an error if it cannot be retrieved.
    */
   getMerkleRootForHeight(
      args: { height: PositiveInteger },
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | { merkleRoot: HexString }
   >;

   /**
    * Retrieves the Bitcoin network the client is using (mainnet or testnet).
    *
    * @param {Object} args - No arguments required, pass an empty object.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} The promise resolves to an object indicating whether the client is using the mainnet or testnet.
    */
   getNetwork(
      args: {},
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | { network: 'mainnet' | 'testnet' }
   >;

   /**
    * Retrieves the current version string of the wallet.
    *
    * @param {Object} args - Empty argument object.
    * @param {OriginatorDomainNameString} [originator] - Fully-qualified domain name (FQDN) of the application that originated the request.
    * @returns {Promise<Object>} Resolves to an object containing the version string of the wallet, or an error.
    */
   getVersion(
      args: {},
      originator?: OriginatorDomainNameString
   ): Promise<
      | {
         status: 'error';
         code: ErrorCodeString10To40Characters;
         description: ErrorDescriptionString20To200Characters;
         context?: Byte[];
      }
      | { version: VersionString7To30Characters }
   >;
}
```

Future specifications can define the same interface using other languages or interface definition schemas such as ASN.1.

#### Conclusion

This interface defines a comprehensive, standardized, and secure Wallet-to-Application interaction model within the BSV ecosystem. By enforcing type constraints, standardizing operations, and maintaining vendor neutrality, it enables a broad and flexible ecosystem where apps and wallets can interoperate efficiently, securely, and reliably across a multitude of environments. Its open and unchanging specification through this document enforces stability while promoting widespread adoption, driving forward the implementation of BSV and allowing applications to build on top.

At long last.
